---
title: 'Shiny Mediator - Getting Started'
description: 'A Mediator Pattern with a focus on Apps written with .NET'
pubDate: 'Oct 03 2025'
heroImage: '../../assets/shinyicon.png'
---

Mediator patterns have been getting a lot of attention lately, and for good reason. They help to decouple components in an application, making it easier to manage complexity and improve maintainability.  Mediator patterns also go by the names "Vertical slice architecture" and CQRS (Command Query Responsibility Segregation). 
The big guy in .NET mediation is obviously [MediatR](https://mediatr.io/) by Jimmy Bogard.  It's an amazing library that has been used by an absolute ton of applications.  It recently went to a paid model, which is understandable given the amount of work that goes into maintaining a library of that size.

The reason for building Shiny Mediator was to create a mediation library, but make sure it works with apps built on platforms like .NET MAUI and Blazor WebAssembly while also including some more "batteries included" features.  This doesn't mean I've neglected things like ASPNET support, but we'll get to that in a future article.

## The Haters

Many engineers will call mediators "over engineering" or "an anti-pattern".  I disagree.  In fact, I think mediators are one of the best patterns for building complex applications without going full insane with microservices out of the gate.  You can run in a monolith while still keeping things decoupled and manageable thereby making it easy to "SLICE" a piece out and move it to a microservice as your application traffic grows.
Another advantage of a mediation pattern is can remove the "dependency injection hell" of adding a services for things like logging, caching, and other cross cutting concerns.  Instead of having to add these services to every handler, you can just add them to the mediator pipeline, configure them or stick an attribute on a handler.

```csharp
public class MyViewModel {
    public MyViewModel(IDataService data, ICacheManager cache, IConfiguration configuration, ILogger<MyViewModel> logger)
}
```

Homegrown/built in mediation patterns are often added, but require you do the growing.  Middleware management is also not a simple process.  Creating keys for caching requests, another whamo of complexity.  These are all things solved by Shiny Mediator.
AI generated code solutions is another one I hear.  "Just use AI to generate the code for you".  AI is great at boilerplate or when you give it a very specific input & output, but architecture... it will throw "slop" at you.

## Experience of the Past

I've seen some large .NET MAUI applications
that had so many engineers working on them, there was constant "fire drills" (the running joke that came to be).  Team A would change something that would break Team B's work.  Team C would have to make changes to Team A's code to update navigation or data retrieval.  
Quite often, these breaking changes wouldn't even be picked up until a regression test.  

In this post, we'll explore how to get started with Shiny Mediator, a library that implements the Mediator pattern with a focus on apps written with .NET.

## What are some of the "batteries included"?

* Offline Mode
    * TODO Sample - Attribute & configuration
* Caching
* What about a cache that survives app restarts, but still respects a cache validity period?
* Performance Metrics
* Validation - Fluent Validation or Data Annotations
* What about a full fledged HTTP client that gives you retries, caching, and offline support with fast AOT complaint serialization without the complexity of setting up HttpClientFactory, System.Text.Json Serialization Contexts, and Polly?


## What's the Road Ahead

Source generation and full blown AOT.  AOT is becoming such an important part of .NET, especially with .NET MAUI and Blazor.  We're working hard on a version 5 release that will be fully AOT compliant out of the box!